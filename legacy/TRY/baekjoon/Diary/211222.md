#### 2021-12-22
G1, G2, G4, S4\*2

## 1. Escaping (BOJ 20041)
작년 icpc 문제로, 그리디 문제이다. 올해 icpc에서 preview 문제로 나왔고,  
icpc를 준비하면서 해답을 알고 있었다.   

핵심은 원점을 도둑의 좌표로 하여, y = x, y= -x 그래프를 그리는 것이다.  
4개의 사분면으로 나눠질 수 있는데, 각 4분면에 해당되는 곳에 경찰이 모두 있어야 도둑을 잡을 수 있다.  
사분면의 경계인 그래프에 경찰이 있다면, 두 사분면을 모두 커버할 수 있는 것이다.  

왜 그런가 하면, 도둑은 항상 한 방향으로 일정하게 뛰어야 유리하다.   
경찰이 도둑에 위치를 운 좋게 알고 있다고 가정하면, 항상 도둑을 잡기 위한 최적의 경로로 뛸 것이기 때문이다.  
그러면 와리가리 하는 것이 소용없다. 도둑이 한 방향으로 뛸 때 경찰이 잡을 수 있는 조건이 위 설명이다.  

조금 문제를 더 어렵게 만든다면, 장애물을 세울 수 있겠다. 장애물을 돌아가는 비용을 계산 해야 할 수 있다.   


## 2. RGB 거리 2 (BOJ 17404)
RGB 거리 문제에서 집이 원 모양으로 놓인 조건으로 바뀐 것이다. 원 모양은 문제 기여 항목을 보고 생각할 수 있었다.  
원 모양일라는 것을 알았다면 더 문제를 쉽게 풀 수 있었을까? 잘 모르겠다.  
나는 그냥 첫 집을 R, G, B 로 칠하는 각 각의 경우를 모두 따져서 풀었다.  

기존 DP 식에서 각 집을 RG, GB ,RB 중의 최솟값을 구해주는데, R로 칠하는 경우 RG = R, GB = MAX, RB = R  
이렇게 설정해주면 첫 집을 R로 칠할 때 최솟값이 나온다. 그리고 마지막에 R로 칠하는 경우를 제외해주면 된다.  
마지막에 칠하는 색깔은 기존 DP식에서도 알 수 있다.   


## 3. 가운데를 말해요 (BOJ 1655)
리스트는 lower bound를 구할 때 O(n)이다. O(n^2)이라 안된다.  
배열이나 벡터는 삽입이 O(n)이므로 O(n^2logn)이라 안된다.  

내가 푸려고 하는 방법은 중간 값을 pivot으로 하고  
pivot 앞에 max_priority_queue를 pivot 뒤에 min_priority_queue를 두는 것이다.  
수의 개수가 홀수이고 pivot보다 작다면 pivot은 오른쪽 min_pq로 밀리고 새로운 수와 max_pq 중 큰 값이 새 pivot이 된다.  
수의 개수가 홀수이고 pivot보다 크거나 같다면 새 수가 오른쪽 min_pq로 들어간다.  
수의 개수가 짝수이고 pivot보다 작거나 같다면 새 수가 왼쪽 max_pq로 들어간다.  
수의 개수가 짝수이고 pivot보다 크다면 pivot은 왼쪽 max_pq로 밀리고 새로운 수와 max_pq 중 큰 값이 새 pivot이 된다.  

아직 채점결과를 받지 못했지만 풀릴 것 같다.  
알고리즘 분류를 안보고 푸는 것이 정말 맞는 방법인 것 같다.  
알고리즘 분류를 보고 푼다면 당연히 거쳐야 할 생각들을 못할 것이다.  
첫 문단 두 줄과 같이. 실전도 당연히 알고리즘 분류는 주어지지 않는다.  


